<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Previous head content remains the same -->
  <style>
    /* Previous styles remain the same */
    
    /* Add loading spinner */
    .loader {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 4px solid var(--primary);
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- Previous HTML remains the same until the script section -->

  <script>
    // App State
    let isLoggedIn = false;
    const ROOT_USER = 'root';
    const ROOT_PASS = 'admin';
    
    // GitHub configuration
    const GITHUB_USERNAME = 'HackBugs';
    const GITHUB_REPO = 'Website-Collection';
    const GITHUB_BRANCH = 'main';
    const GITHUB_FILE_PATH = 'Website_Data/data.json';
    const GITHUB_TOKEN = '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'; // You'll need to add your GitHub token here
    
    // Load saved data
    let data = [];
    
    // DOM Elements
    const authScreen = document.getElementById('auth-screen');
    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const adminControls = document.getElementById('admin-controls');
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    const categoriesContainer = document.getElementById('categories');

    // Initialize
    async function init() {
      // Check for saved dark mode preference
      if (localStorage.getItem('darkMode') === 'true') {
        document.body.classList.add('dark-mode');
        darkModeToggle.checked = true;
      }

      // Set up event listeners
      darkModeToggle.addEventListener('change', toggleDarkMode);
      
      // Check if user was previously logged in
      if (localStorage.getItem('isLoggedIn') === 'true') {
        isLoggedIn = true;
        updateUI();
      }
      
      // Show loading state
      categoriesContainer.innerHTML = '<div class="loader"></div>';
      
      // Load data from GitHub
      try {
        data = await loadDataFromGitHub();
        render();
      } catch (error) {
        console.error('Failed to load data from GitHub:', error);
        // Fallback to local storage if GitHub fails
        const localData = localStorage.getItem("websiteData");
        data = localData ? JSON.parse(localData) : [];
        render();
        alert('Failed to load data from GitHub. Using local data instead.');
      }
    }

    // GitHub API functions
    async function loadDataFromGitHub() {
      if (!GITHUB_TOKEN) {
        throw new Error('GitHub token not configured');
      }
      
      const url = `https://api.github.com/repos/${GITHUB_USERNAME}/${GITHUB_REPO}/contents/${GITHUB_FILE_PATH}?ref=${GITHUB_BRANCH}`;
      
      const response = await fetch(url, {
        headers: {
          'Authorization': `token ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }
      
      const fileData = await response.json();
      const content = atob(fileData.content); // Decode base64 content
      return JSON.parse(content);
    }
    
    async function saveDataToGitHub() {
      if (!GITHUB_TOKEN) {
        throw new Error('GitHub token not configured');
      }
      
      // First, get the current file SHA to update it
      const getUrl = `https://api.github.com/repos/${GITHUB_USERNAME}/${GITHUB_REPO}/contents/${GITHUB_FILE_PATH}?ref=${GITHUB_BRANCH}`;
      let sha = null;
      
      try {
        const getResponse = await fetch(getUrl, {
          headers: {
            'Authorization': `token ${GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (getResponse.ok) {
          const fileData = await getResponse.json();
          sha = fileData.sha;
        }
      } catch (error) {
        console.log('File may not exist yet, creating new file');
      }
      
      // Prepare the update request
      const updateUrl = `https://api.github.com/repos/${GITHUB_USERNAME}/${GITHUB_REPO}/contents/${GITHUB_FILE_PATH}`;
      const content = btoa(JSON.stringify(data, null, 2)); // Encode to base64
      const message = `Update website data ${new Date().toISOString()}`;
      
      const response = await fetch(updateUrl, {
        method: 'PUT',
        headers: {
          'Authorization': `token ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          message,
          content,
          sha,
          branch: GITHUB_BRANCH
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save data to GitHub: ${response.status}`);
      }
      
      // Also save to local storage as fallback
      localStorage.setItem("websiteData", JSON.stringify(data));
      
      return response.json();
    }

    // Previous functions remain the same until saveData()
    
    // Modified saveData function
    async function saveData() {
      try {
        await saveDataToGitHub();
      } catch (error) {
        console.error('Failed to save to GitHub:', error);
        // Fallback to local storage
        localStorage.setItem("websiteData", JSON.stringify(data));
        alert('Failed to save to GitHub. Data saved locally instead.');
      }
    }

    // Previous functions remain the same
    
    // Modify all functions that change data to use async/await
    async function addCategory() {
      const name = prompt("Enter Category Name:");
      if (name) {
        data.push({ name, websites: [] });
        await saveData();
        render();
      }
    }

    async function editCategory(index) {
      const newName = prompt("Edit Category Name:", data[index].name);
      if (newName) {
        data[index].name = newName;
        await saveData();
        render();
      }
    }

    async function removeCategory(index) {
      if (confirm(`Delete "${data[index].name}" category and all its websites?`)) {
        data.splice(index, 1);
        await saveData();
        render();
      }
    }

    async function addWebsite(index) {
      const title = prompt("Enter Website Title:");
      const link = prompt("Enter Website URL:");
      
      if (title && link) {
        const formattedLink = link.startsWith('http') ? link : `https://${link}`;
        data[index].websites.push({ title, link: formattedLink });
        await saveData();
        render();
      }
    }

    async function editWebsite(catIndex, webIndex) {
      const website = data[catIndex].websites[webIndex];
      const newTitle = prompt("Edit Title:", website.title);
      const newLink = prompt("Edit Link:", website.link);
      
      if (newTitle && newLink) {
        const formattedLink = newLink.startsWith('http') ? newLink : `https://${newLink}`;
        data[catIndex].websites[webIndex] = { title: newTitle, link: formattedLink };
        await saveData();
        render();
      }
    }

    async function removeWebsite(catIndex, webIndex) {
      if (confirm(`Delete "${data[catIndex].websites[webIndex].title}" website?`)) {
        data[catIndex].websites.splice(webIndex, 1);
        await saveData();
        render();
      }
    }

    // Initialize the app
    init();
  </script>
</body>
</html>
